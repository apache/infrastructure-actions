name: Build a Pelican Website
description: "Generate a Pelican website from Markdown"    
inputs:
  destination:
    description: "Pelican Output branch"
    required: false
    default: "asf-site"
  publish:
    description: "Publish the site to the destination branch. If false, the site is built but not published."
    required: false
    default: "true"
  gfm:
    description: "Uses GitHub Flavored Markdown"
    required: false
    default: 'true'
  output:
    description: "Pelican generated output directory"
    required: false
    default: 'output'
  tempdir:
    description: "Temporary Directory name"
    required: false
    default: '../output.tmp'
  debug:
    description: "Pelican Debug mode"
    required: false
    default: 'false'
  version:
    description: "Pelican Version (default 4.5.4)"
    required: false
    default: '4.5.4'
  requirements:
    description: "Python requirements file name to install (default: None)"
    required: false
  fatal:
    description: "Value for --fatal option [errors|warnings] - sets exit code to error (default: errors)"
    required: false
    default: 'errors'
runs:
  using: "composite"
  steps:
    - name: Install Pelican
      env:
        debug: ${{ inputs.debug }}
        version: ${{ inputs.version }}
      shell: bash
      # Install needs to run in separate shell so stdout is restored
      run: |
        (
          test "${debug}" == 'true' || exec >/dev/null
          PIP_BREAK_SYSTEM_PACKAGES=1 pip3 install pelican==${version} markdown bs4 ezt requests markupsafe==2.0.1
        )
        python3 -V
        echo "Pelican version:"
        pelican --version
        if [ "${debug}" == 'true' ]
        then
          pip3 list # This a long list
        fi

    # If the site uses Github Flavored Markdown, use this build branch
    - name: fetch and build libcmark-gfm.so
      if: ${{ inputs.gfm == 'true' }}
      shell: bash
      env:
        GFM_VERSION: '0.28.3.gfm.12' # ensure we agree with build-cmark.sh script
        debug: ${{ inputs.debug }}
      run: |
        if [[ -z $LIBCMARKDIR ]] # define LIBCMARKDIR if it is not already
        then
          # set up the GFM environment
          export LIBCMARKDIR=/opt/pelican-asf/gfm-${GFM_VERSION} # arbitrary, but should contain version
          mkdir -p $LIBCMARKDIR
          echo  "LIBCMARKDIR=${LIBCMARKDIR}" >>$GITHUB_ENV # needed for the build step
        fi

        # Does the GFM build already exist?
        if [[ -f $LIBCMARKDIR/libcmark-gfm.so ]]
        then
          echo "Already have GFM binary at $LIBCMARKDIR, skipping build"
          exit 0 # nothing more to do in this step
        fi
        {
          echo "Creating GFM binary in ${LIBCMARKDIR}"
          # disable stdout unless debug is on
          if [ "${debug}" == 'true' ]
          then
            # This envvar is used within build-cmark.sh
            DEBUG_STEPS=1; export DEBUG_STEPS
          else
            exec >/dev/null
          fi
          # build the code and define LIBCMARKDIR under $WORKDIR
          bash ${GITHUB_ACTION_PATH}/build-cmark.sh $GFM_VERSION $LIBCMARKDIR
        }

    - name: Generate website from markdown
      env:
        requirements: ${{ inputs.requirements }}
        debug: ${{ inputs.debug }}
        fatal: ${{ inputs.fatal }}
        tempdir: ${{ inputs.tempdir }}
      shell: bash
      run: |
        if [ -n "${requirements}" ]
        then
          echo "Installing python requirements from ${requirements}"
          PIP_BREAK_SYSTEM_PACKAGES=1 pip3 install -r ${requirements}
        fi
        if [ "${debug}" == 'true' ]
        then
          OPTS='-D'
        else
          OPTS=''
        fi
        if [ -n "${fatal}" ]
        then
          OPTS="$OPTS --fatal ${fatal}"
        fi
        echo "Getting plugins from action location: ${GITHUB_ACTION_PATH}"
        PP=$(python3 ${GITHUB_ACTION_PATH}/plugin_paths.py "${GITHUB_ACTION_PATH}/plugins")
        set -x # Show the expanded variables
        python3 -B -m pelican content -e "$PP" -o ${tempdir} $OPTS

    - name: Check out previous branch
      if: ${{ inputs.publish == 'true' }}
      env:
        destination: ${{ inputs.destination }}
        ref_name: ${{ inputs.ref_name }}
      shell: bash
      run: | 
        git config --global user.email "private@infra.apache.org"
        git config --global user.name "Build Pelican (action)"
        git remote update
        if git checkout ${destination}
        then
          git pull origin ${destination}
        else
          # if none, create it.
          echo "branch ${destination} is new; create empty site"
          git switch --orphan ${destination}
          git checkout origin/${ref_name} -- .asf.yaml
          git add .asf.yaml -f
          git commit -m "Initialise empty site"
          git push -u origin ${destination}
        fi

    - name: Commit Directly to the branch
      if: ${{ inputs.publish == 'true' }}
      env:
        output: ${{ inputs.output }}
        tempdir: ${{ inputs.tempdir }}
      shell: bash
      run: |
        # Remove all existing output so deletions will be captured
        rm -rf ${output}
        git rm --quiet -r --ignore-unmatch --cached ${output}/*
        # replace with generated output
        mv ${tempdir} ${output}
        git diff # Show changes
        git add ${output}
        git status
        if git commit -m "Commit build products"
          then
              git push
        else
          echo "No change"
          true # ensure step is successful
        fi
